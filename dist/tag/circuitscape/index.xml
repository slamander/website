<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Circuitscape | Baecher Research</title><link>https://alexbaecher.com/tag/circuitscape/</link><atom:link href="https://alexbaecher.com/tag/circuitscape/index.xml" rel="self" type="application/rss+xml"/><description>Circuitscape</description><generator>Hugo Blox Builder (https://hugoblox.com)</generator><language>en-us</language><copyright>© 2025 Alex Baecher</copyright><lastBuildDate>Wed, 12 Aug 2020 00:40:04 -0700</lastBuildDate><image><url>https://alexbaecher.com/media/logo_hu2039277577754200582.png</url><title>Circuitscape</title><link>https://alexbaecher.com/tag/circuitscape/</link></image><item><title>Mapping Ecological Flow in R (pt 1)</title><link>https://alexbaecher.com/post/connectivity-script/</link><pubDate>Wed, 12 Aug 2020 00:40:04 -0700</pubDate><guid>https://alexbaecher.com/post/connectivity-script/</guid><description>&lt;h2 id="focusing-on-randomized-paths-between-multiple-locations-or-populations-habitats-etc">Focusing on randomized paths between multiple locations (or populations, habitats, etc)&lt;/h2>
&lt;p>&lt;strong>Note&lt;/strong> This is simply a tutorial. I’m not (for now) providing a review
of the literature surrounding ecological connectivity, or commenting the
different meanings of connectivity). This tutorial is strictly for
demonstrating how to perform such an analysis, because–to my
knowledge–such a tutorial doesn’t exist. That being said, please let me
know if you find one!&lt;/p>
&lt;p>This analysis can be done in R using one of two methods: 1. using the R
package &lt;code>gdistance&lt;/code>, which performs the analysis natively 2. calling
Circuitscape, an external GUI-based software widely used in ecology,
from R&lt;/p>
&lt;p>In the future, I will post about using Circuitscape in R, making use of
command prompt and a combination of packages, including Bill Peterman’s
&lt;code>ResistanceGA&lt;/code>. For now, I’m going to focus on performing the analysis
natively using &lt;code>gdistance&lt;/code>. Although, &lt;code>gdistance&lt;/code> is only programmed to
analysis randomized shortest-path between two locations, I will
demonstrate how, through the use of a simple loop, you can perform the
analysis in R.&lt;/p>
&lt;p>For the analysis, I will &lt;em>only&lt;/em> use widely publically available data
sets. As for a species, I’ve chosen the very charasmatic Jordan’s Red
Cheeked Salamander, endemic to the Great Smoky Mountains National Park
(USA).&lt;/p>
&lt;figure id="figure-jordans-red-cheeked-salamander">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img alt="Jordan&amp;#39;s Red Cheeked Salamander" srcset="
/media/posts/connectivity_script_files/figure-markdown_strict/jrcs_hu8748387886065202433.webp 400w,
/media/posts/connectivity_script_files/figure-markdown_strict/jrcs_hu8774435472472496843.webp 760w,
/media/posts/connectivity_script_files/figure-markdown_strict/jrcs_hu8093516403498535379.webp 1200w"
src="https://alexbaecher.com/media/posts/connectivity_script_files/figure-markdown_strict/jrcs_hu8748387886065202433.webp"
width="760"
height="446"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Jordan&amp;rsquo;s Red Cheeked Salamander
&lt;/figcaption>&lt;/figure>
&lt;p>For this tutorial, you’re going to need the following libraries
installed:&lt;/p>
&lt;ul>
&lt;li>&lt;code>gdistance&lt;/code>&lt;/li>
&lt;li>&lt;code>tidyverse&lt;/code>&lt;/li>
&lt;li>&lt;code>rgeos&lt;/code>&lt;/li>
&lt;li>&lt;code>elevatr&lt;/code>&lt;/li>
&lt;li>&lt;code>ggplot2&lt;/code>&lt;/li>
&lt;li>&lt;code>tigris&lt;/code>&lt;/li>
&lt;li>&lt;code>spocc&lt;/code>&lt;/li>
&lt;li>&lt;code>raster&lt;/code>&lt;/li>
&lt;li>&lt;code>viridis&lt;/code>&lt;/li>
&lt;li>&lt;code>ggthemes&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>To save space and reduce the amount of intermediate variables, I will
make use of the &lt;code>tidyverse&lt;/code> syntax. This includes using data processing
features of &lt;code>dplyr&lt;/code> as well as pipes (&lt;code>%&amp;gt;%&lt;/code>). If you prefer not to use
these features, simply focus on the key functions and data sources which
can easily be incorporated into your own preferred work flow.&lt;/p>
&lt;h2 id="lets-get-started">Let’s get started!&lt;/h2>
&lt;p>First, lets download a shapefile to work with.&lt;/p>
&lt;pre>&lt;code>library(tigris) # Tigris package for USA census data
library(tidyverse)
states &amp;lt;- states()
se &amp;lt;- states %&amp;gt;%
subset(REGION == &amp;quot;3&amp;quot;)
TN_NC &amp;lt;- se %&amp;gt;% # Subsetting the data to Tennessee and North Carolina
subset(NAME %in% c(&amp;quot;Tennessee&amp;quot;, &amp;quot;North Carolina&amp;quot;))
&lt;/code>&lt;/pre>
&lt;p>Next, lets download some species occurrence records for Jordan’s Red
Cheeked Salamander (JRCS) from the Global Biodiversity Information
Facility using the R package &lt;code>spocc&lt;/code>. In this query, I will pull &lt;em>only
the first&lt;/em> 1000 records. Yes, that means I’m pulling records in no
particular order, and that they can be biased. Don’t @ me.&lt;/p>
&lt;pre>&lt;code>library(spocc)
## Warning: package 'spocc' was built under R version 4.0.2
library(raster)
## Warning: package 'raster' was built under R version 4.0.2
## Loading required package: sp
##
## Attaching package: 'raster'
## The following object is masked from 'package:dplyr':
##
## select
## The following object is masked from 'package:tidyr':
##
## extract
Pj &amp;lt;- occ(query = &amp;quot;Plethodon jordani&amp;quot;, # JRCS scientific name
from = &amp;quot;gbif&amp;quot;, # limiting query to *the first* 1000 records
limit=1000, # limiting query to *the first* 1000 records
has_coords = T) # limiting those 1000 records to those that have geo-referenced data
&lt;/code>&lt;/pre>
&lt;p>Now that we have the data, we need to organize and clean it using
&lt;code>dplyr&lt;/code>. Luckily, &lt;code>spocc&lt;/code> has improved their naming system, so this is
easier to do now.&lt;/p>
&lt;pre>&lt;code>Pj_sp &amp;lt;- Pj$gbif$data$Plethodon_jordani %&amp;gt;% # Grabbing the Darwin-core data from the spocc object
dplyr::select(longitude, # Keep locations and year, discard the rest
latitude,
year) %&amp;gt;%
dplyr::filter(year &amp;gt; 2000) %&amp;gt;% # Filter records to only those after year 2000
filter(!duplicated(round(longitude, 2), # Remove duplicate records using rounded decimals (this removes points very near to one-another)
round(latitude, 2)) == TRUE) %&amp;gt;% # &amp;gt;&amp;gt; See notes below about ^^
dplyr::mutate(lon = scale(longitude), # Remove points far outside the cluster of occurrences
lat = scale(latitude)) %&amp;gt;% # &amp;gt;&amp;gt; See notes below about ^^
dplyr::filter(!abs(lon)&amp;gt;2) %&amp;gt;%
dplyr::filter(!abs(lat)&amp;gt;2) %&amp;gt;%
dplyr::select(longitude,
latitude) %&amp;gt;%
SpatialPoints(proj4string = crs(se))
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Notes&lt;/strong> To remove stacked points, or points that are clustered very
closely, I rounded the decimal points to the second hundreths place and
removed duplicates. This step is actually very biologically meaningful…
Because we want to map potential flow between populations of JRCS, we
want each point to represent a population–meaning each point must be
sufficiently isolated so as to only be connected through stochastic
disperal. Because JRCS is dispersal limited, I chose to remove points
less that ~10 km from one another (approximately the resolution of the
second decimal point of a gps coordinate).&lt;/p>
&lt;p>I removed points that were suspiciously far outside the cluster of
presences by creating new variables: &lt;code>lon&lt;/code> and &lt;code>lat&lt;/code>, which are Z-scores
of the latitude and longitude variables (by subtracting the mean and
dividing by standard deviation, or using the &lt;code>scale&lt;/code> function). I them
removed values greater that 2, which represent points that are two
standard deviations from the mean latitude and mean longitude.&lt;/p>
&lt;p>Let’s plot our points&lt;/p>
&lt;pre>&lt;code>library(ggplot2)
library(viridis)
## Loading required package: viridisLite
library(ggthemes)
ggplot() + geom_polygon(data=se, aes(x=long, y=lat, grou=group), col=&amp;quot;grey40&amp;quot;, fill=&amp;quot;grey80&amp;quot;) +
geom_polygon(data=TN_NC, aes(x=long, y=lat), col=&amp;quot;grey40&amp;quot;, fill=&amp;quot;light blue&amp;quot;) +
coord_quickmap() + theme_map()
## Regions defined for each Polygons
## Warning: Ignoring unknown aesthetics: grou
## Regions defined for each Polygons
&lt;/code>&lt;/pre>
&lt;figure id="figure-jordans-red-cheeked-salamander">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img alt="Jordan&amp;#39;s Red Cheeked Salamander" srcset="
/media/posts/connectivity_script_files/figure-markdown_strict/plot_presences-1_hu15505977354153264823.webp 400w,
/media/posts/connectivity_script_files/figure-markdown_strict/plot_presences-1_hu2728833307136772739.webp 760w,
/media/posts/connectivity_script_files/figure-markdown_strict/plot_presences-1_hu18335796353493736808.webp 1200w"
src="https://alexbaecher.com/media/posts/connectivity_script_files/figure-markdown_strict/plot_presences-1_hu15505977354153264823.webp"
width="672"
height="480"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Jordan&amp;rsquo;s Red Cheeked Salamander
&lt;/figcaption>&lt;/figure>
&lt;p>To create a custom study area, shaped to our occurrence points, we can
create a convex hull around our points using &lt;code>chull()&lt;/code>.&lt;/p>
&lt;pre>&lt;code>Pj_coords &amp;lt;- Pj_sp@coords
Pj_chull &amp;lt;- chull(Pj_sp@coords) # Creating convex hull
Pj_chull_ends &amp;lt;- Pj_sp@coords[c(Pj_chull, Pj_chull[1]),] # generate the end points of polygon.
Pj_poly &amp;lt;- SpatialPolygons(
list(Polygons(
list(Polygon(Pj_chull_ends)), ID=1)),
proj4string = crs(se)) # convert coords to SpatialPolygons
&lt;/code>&lt;/pre>
&lt;p>Now, we will create a buffer around those points using
&lt;code>rgeos::gBuffer()&lt;/code>.&lt;/p>
&lt;pre>&lt;code>library(rgeos)
Pj_poly_buff &amp;lt;- gBuffer(Pj_poly, width = 0.05, byid=T)
&lt;/code>&lt;/pre>
&lt;p>Let’s have a look at your buffered polygon:&lt;/p>
&lt;pre>&lt;code>ggplot() + geom_polygon(data=TN_NC, aes(x=long, y=lat), col=&amp;quot;grey40&amp;quot;, fill=&amp;quot;light blue&amp;quot;) +
geom_polygon(data=Pj_poly_buff, aes(x=long, y=lat, grou=group), col=&amp;quot;grey40&amp;quot;, fill=&amp;quot;pink&amp;quot;) +
geom_point(data=as.data.frame(Pj_sp@coords), aes(x=longitude, y=latitude), size=0.01) +
coord_quickmap() + theme_map()
## Regions defined for each Polygons
## Warning: Ignoring unknown aesthetics: grou
&lt;/code>&lt;/pre>
&lt;figure id="figure-buffered-polygon">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img alt="Buffered polygon" srcset="
/media/posts/connectivity_script_files/figure-markdown_strict/unnamed-chunk-1-1_hu4160553860264835895.webp 400w,
/media/posts/connectivity_script_files/figure-markdown_strict/unnamed-chunk-1-1_hu14299404557036398538.webp 760w,
/media/posts/connectivity_script_files/figure-markdown_strict/unnamed-chunk-1-1_hu3578149591007381430.webp 1200w"
src="https://alexbaecher.com/media/posts/connectivity_script_files/figure-markdown_strict/unnamed-chunk-1-1_hu4160553860264835895.webp"
width="672"
height="480"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Buffered polygon
&lt;/figcaption>&lt;/figure>
&lt;p>To create our resistance layers for the connectivity analysis, let’s
download a digital elevation model (DEM) using package &lt;code>elevatr&lt;/code>.&lt;/p>
&lt;pre>&lt;code>library(elevatr)
elevation &amp;lt;- get_elev_raster(Pj_poly_buff, z = 8) # This will find a DEM tile nearest to our polygon
&lt;/code>&lt;/pre>
&lt;p>While elevation is important, we can derive other biologically important
variables using the &lt;code>raster::terrain()&lt;/code>, inlcuding aspect (direction a
hillside is facing) and topographic roughness index (TRI). In very
simple terms, TRI calculates the change in elevation between a point and
its surroundings (in a neighborhood of 8 points).&lt;/p>
&lt;pre>&lt;code>elv &amp;lt;- elevation %&amp;gt;% # First, lets cut the DEM to our study area
crop(Pj_poly_buff) %&amp;gt;% # crop to the extent
mask(Pj_poly_buff) # mask to the edges
asp &amp;lt;- terrain(elv, opt=&amp;quot;aspect&amp;quot;, neighbors = 8) # Calculate aspect
ggplot(as.data.frame(asp, xy=T)) + geom_raster(aes(x=x, y=y, fill=aspect)) +
scale_fill_continuous(na.value=NA) + theme_map() + theme(legend.position = &amp;quot;right&amp;quot;)
## Warning: Removed 18361 rows containing missing values (geom_raster).
&lt;/code>&lt;/pre>
&lt;figure id="figure-creating-gis-layers-for-the-great-smoky-mtns">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img alt="creating gis layers for the Great Smoky Mtns" srcset="
/media/posts/connectivity_script_files/figure-markdown_strict/create_layers-1_hu1715431012424902423.webp 400w,
/media/posts/connectivity_script_files/figure-markdown_strict/create_layers-1_hu14616543833048540915.webp 760w,
/media/posts/connectivity_script_files/figure-markdown_strict/create_layers-1_hu17860438836242113234.webp 1200w"
src="https://alexbaecher.com/media/posts/connectivity_script_files/figure-markdown_strict/create_layers-1_hu1715431012424902423.webp"
width="384"
height="288"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
creating gis layers for the Great Smoky Mtns
&lt;/figcaption>&lt;/figure>
&lt;p>To simplify our analysis for this demonstration, I’m going to cut down
the number of presence points to only 5. Because we will be calculating
pairwise random shortest-paths (from now on, “random walks”), we will
calculate 10 paths.&lt;/p>
&lt;pre>&lt;code>set.seed(6) # To make your results match mine
Pj_sample &amp;lt;- Pj_coords[sample(nrow(Pj_coords), 5),] # Take 5 random locations
ggplot(as.data.frame(asp, xy=T)) + geom_raster(aes(x=x, y=y, fill=aspect)) +
geom_point(data=as.data.frame(Pj_sample), aes(x=longitude, y=latitude), size=2, col=&amp;quot;white&amp;quot;) +
scale_fill_continuous(na.value=NA) + theme_map()
## Warning: Removed 18361 rows containing missing values (geom_raster).
&lt;/code>&lt;/pre>
&lt;figure id="figure-random-sample-of-sites-in-the-great-smoky-mtns">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img alt="random sample of sites in the Great Smoky Mtns" srcset="
/media/posts/connectivity_script_files/figure-markdown_strict/gather_random_sample_of_sites-1_hu17435859837055058397.webp 400w,
/media/posts/connectivity_script_files/figure-markdown_strict/gather_random_sample_of_sites-1_hu15156685734228406591.webp 760w,
/media/posts/connectivity_script_files/figure-markdown_strict/gather_random_sample_of_sites-1_hu15449460719916003691.webp 1200w"
src="https://alexbaecher.com/media/posts/connectivity_script_files/figure-markdown_strict/gather_random_sample_of_sites-1_hu17435859837055058397.webp"
width="480"
height="384"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
random sample of sites in the Great Smoky Mtns
&lt;/figcaption>&lt;/figure>
&lt;p>To make our pairwise random walks, we have to create a side index.
Here’s quick little solution I made which creates a matrix of every
conceivable combination of points:&lt;/p>
&lt;pre>&lt;code>Pj_combn &amp;lt;- combn(nrow(Pj_sample),2) %&amp;gt;%
t() %&amp;gt;%
as.matrix()
&lt;/code>&lt;/pre>
&lt;p>To perform a random walks analysis, we have to create a transition
matrix using &lt;code>gdistance::transition()&lt;/code>, as well as perform a
geocorrection.&lt;/p>
&lt;pre>&lt;code>library(gdistance)
asp_tr &amp;lt;- transition(asp, transitionFunction = mean, 4) %&amp;gt;%
geoCorrection(type=&amp;quot;c&amp;quot;,multpl=F)
&lt;/code>&lt;/pre>
&lt;p>Now comes the fun part. This loop will perform the random walk routine
using &lt;code>gdistance:passage()&lt;/code> for each pairwise path, generating a flow
map. This flow map can be considered as “conductance” a la Circuitscape,
or the “probabilities of passages” based on randomized shortest-paths.&lt;/p>
&lt;pre>&lt;code>passages &amp;lt;- list() # Create a list to store the passage probability rasters in
system.time( # Keep track of how long this takes
for (i in 1:nrow(Pj_combn)) {
locations &amp;lt;- SpatialPoints(rbind(Pj_sample[Pj_combn[i,1],1:2], # create origin points
Pj_sample[Pj_combn[i,2],1:2]), # create destination (or goal) points, to traverse
crs(se))
passages[[i]] &amp;lt;- passage(asp_tr, # run the passage function
origin=locations[1], # set orgin point
goal=locations[2], # set goal point
theta = 0.00001) # set theta (tuning parameter, see notes below)
print(paste((i/nrow(Pj_combn))*100, &amp;quot;% complete&amp;quot;))
}
)
## [1] &amp;quot;10 % complete&amp;quot;
## [1] &amp;quot;20 % complete&amp;quot;
## [1] &amp;quot;30 % complete&amp;quot;
## [1] &amp;quot;40 % complete&amp;quot;
## [1] &amp;quot;50 % complete&amp;quot;
## [1] &amp;quot;60 % complete&amp;quot;
## [1] &amp;quot;70 % complete&amp;quot;
## [1] &amp;quot;80 % complete&amp;quot;
## [1] &amp;quot;90 % complete&amp;quot;
## [1] &amp;quot;100 % complete&amp;quot;
## user system elapsed
## 15.89 2.88 18.76
passages &amp;lt;- stack(passages) # create a raster stack of all the passage probabilities
passages_overlay &amp;lt;- sum(passages)/nrow(Pj_combn) # calculate average
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Notes&lt;/strong> In our passage function, we set theta, (&lt;em>θ&lt;/em>), a tuning
parameter. Extremely low values result in a random walk (equivilant to
Circuit Theory), but as &lt;em>θ&lt;/em>¸ increases, the passage converges on least
cost path. I supplied a value somewhere in the middle.&lt;/p>
&lt;pre>&lt;code>colors &amp;lt;- c(&amp;quot;grey60&amp;quot;, viridis_pal(option=&amp;quot;plasma&amp;quot;, begin = 0.3, end = 1)(20))
ggplot(as.data.frame(passages_overlay, xy=T)) + geom_raster(aes(x=x,y=y,fill=layer)) +
scale_fill_gradientn(colors = colors, na.value = NA) +
theme_map() + theme(legend.position = &amp;quot;right&amp;quot;)
## Warning: Removed 18361 rows containing missing values (geom_raster).
&lt;/code>&lt;/pre>
&lt;figure id="figure-ecological-flow-of-jordans-red-cheeked-salamander">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img alt="Ecological Flow of Jordan&amp;#39;s Red Cheeked Salamander" srcset="
/media/posts/connectivity_script_files/figure-markdown_strict/plot_flow-1_hu3668783389650275206.webp 400w,
/media/posts/connectivity_script_files/figure-markdown_strict/plot_flow-1_hu1841305405371726403.webp 760w,
/media/posts/connectivity_script_files/figure-markdown_strict/plot_flow-1_hu2997340114314834329.webp 1200w"
src="https://alexbaecher.com/media/posts/connectivity_script_files/figure-markdown_strict/plot_flow-1_hu3668783389650275206.webp"
width="760"
height="136"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Ecological Flow of Jordan&amp;rsquo;s Red Cheeked Salamander
&lt;/figcaption>&lt;/figure>
&lt;p>There you have it!&lt;/p>
&lt;p>Now, this was an &lt;em>extremely&lt;/em> short demonstration… In the future, I plan
to make many additional posts on connectivity, what it means, how to use
it, as well as provide some more tutorials.&lt;/p>
&lt;p>Best,&lt;/p>
&lt;p>-Alex.&lt;/p></description></item></channel></rss>